# README

## クローンしたときにすること

- `npm install`
- env.template をコピーしてファイル名を.env にする

## 作業毎にすること

- `npm run docker:start`

## コーディング規約

- src/app はコロケーションする
  - 一つ上のディレクトリで使用できるようにするには index.ts に記述する
  - .tsx は積極的に分割すること
- src/components, src/lib は共通フォルダのため、すべてのファイルに public アノテーションを付与すること

## テスト規約

〇〇のとき、✕✕ すべき
〇〇：条件
✕✕：期待値
例：存在しないコードが入力されたとき、false を返すべき
[Jest の Tips 集 10 選。サーバーサイドで Node.js の Jest を書いたことない人向け](https://zenn.dev/kanasugi/articles/b49bd464311053)

## CQRS(フロントエンドとバックエンドの役割分担について)

- フロントエンドでは、クエリの実行をしていい(暫定) -> 将来的にはバックエンドでクエリの実行をするようにする?
- 例：` prisma.〇〇.findMany()``prisma.〇〇.findUnique() `
- コマンドの実行はバックエンドを通じて行う。
- 理由として、クエリは
  - 整合性を担保する必要がない
  - 画面の関心事とドメインの関心事が一致しないため

## バックエンド

- オニオンアーキテクチャーベース

##### 各層の役割について

- コントローラー層 - リクエストの受け取り - 認証処理 - ユースケースの実行 - 例外処理 - レスポンスの返却
  　- ユースケース層 - 処理の組み立て
- リポジトリ層
  - DB 操作
- ドメイン層
  - ドメイン

##### 依存関係

- コントローラー層 -> ユースケース層
- ユースケース層 -> リポジトリ層とドメイン層
- リポジトリ層 -> ドメイン層
- ドメイン層 -> なし
  (リポジトリ層の依存関係を逆転させてません。)

### 例外処理

##### フロントエンド

- 受け取ったレスポンスにユーザー向けのエラーメッセージがあれば、それをトーストで表示する
- なければエラーコードからエラーメッセージを作成してトーストで表示する

##### バックエンド

- 各層で発生した例外はコントローラー層で受け取る(コントローラー層のみ`tryCatch文`を実行できる)
- コントローラー層の catch 文中はログ解析できるように、必要な情報を console.error に出力する(ユーザー ID やリクエストデータなど)
- console.log と throw new Error()が自動的に CloudLogging に出力される
- (きっちりやるなら Result 型を用いて想定しうるエラーをコントローラー層にリフトアップしていって、ユーザーにエラーメッセージを返してもいいかも)

### ユースケース層のメモ

- ロングトランザクションの実行
- ユースケースはリファクタが用意なので、手続き的に書いてもよい。ドメイン層とリポジトリ層とコントローラー層を汚してはいけない。かわりにリファクタが容易なユースケース層を汚す

### ドメイン層メモ

- ドメインルールを記述する
- 集約ルートからしか、エンティティ、値オブジェクトは触らない。集約ルート以外から触るときは、集約ルートのメソッドを使う
